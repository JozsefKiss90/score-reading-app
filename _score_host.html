
<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  html, body { margin:0; padding:0; background:#1b1b1b; }
  #frame { position:relative; width:100%; height:100vh; overflow:hidden; }
  #cursor {
    position:absolute; top:0; bottom:0; width:2px; background:#ff2d2d; z-index:99999;
    transform: translateX(-1px);
  }
  #page { position:absolute; inset:0; border:none; width:100%; height:100%; }
  #hud { position:absolute; right:8px; top:8px; color:#fff; font:12px/1.3 system-ui; background:rgba(0,0,0,.5); padding:6px 8px; border-radius:6px; }
</style>
</head>
<body>
  <div id="frame">
    <div id="cursor"></div>
    <object id="page" type="image/svg+xml" data=""></object>
    <div id="hud">–</div>
  </div>

<script>
let PAGE_IDX = 0;
let MEASURE_BOXES = [];   // array of {left,right,top,bottom} for this page
let READY = false;

function svgDoc() {
  const obj = document.getElementById('page');
  try { return obj.contentDocument; } catch(e) { return null; }
}
function svgEl() { const d = svgDoc(); return d ? d.querySelector('svg') : null; }

function computeMeasureBoxes() {
  const svg = svgEl();
  if (!svg) return [];

  const boxes = [];
  const measures = svg.querySelectorAll('g.measure,[class*="measure"]');
  if (measures.length > 0) {
    measures.forEach(m => {
      const r = m.getBoundingClientRect();
      if (r && isFinite(r.left) && isFinite(r.right) && isFinite(r.top) && isFinite(r.bottom)) {
        boxes.push({left: Math.round(r.left), right: Math.round(r.right), top: Math.round(r.top), bottom: Math.round(r.bottom)});
      }
    });
  } else {
    // Fallback: slice systems by first/last note x per system
    const byTop = {};
    const notes = svg.querySelectorAll('[data-vrv-type="note"],[data-type="note"],.note,g.note,.notehead');
    notes.forEach(n => {
      const r = n.getBoundingClientRect();
      if (r && isFinite(r.left) && isFinite(r.top)) {
        const key = Math.round(r.top);
        const row = (byTop[key] ||= {left: Infinity, right: -Infinity, top: r.top, bottom: r.bottom});
        row.left = Math.min(row.left, r.left);
        row.right = Math.max(row.right, r.right);
      }
    });
    const rows = Object.values(byTop).sort((a,b)=>a.top-b.top);
    rows.forEach(row => boxes.push({left: Math.round(row.left), right: Math.round(row.right), top: Math.round(row.top), bottom: Math.round(row.bottom)}));
  }

  // Ensure sorted left->right within reading order (top->bottom, then left->right)
  boxes.sort((a,b)=> a.top===b.top ? a.left-b.left : a.top-b.top);
  return boxes;
}

function refreshBoxesAndHud() {
  MEASURE_BOXES = computeMeasureBoxes();
  READY = true;
  document.getElementById('hud').textContent = `page=${PAGE_IDX} measures=${MEASURE_BOXES.length}`;
  console.log('[ScoreView/JS] computed measure boxes:', MEASURE_BOXES.length);
}

function setCursorInMeasure(localMeasureIndex, frac01) {
  if (!READY) { console.warn('[ScoreView/JS] not ready'); return; }
  if (MEASURE_BOXES.length === 0) return;

  const i = Math.max(0, Math.min(MEASURE_BOXES.length-1, Math.round(localMeasureIndex)));
  const m = MEASURE_BOXES[i];
  const x = m.left + Math.max(0, Math.min(1, frac01)) * Math.max(1, (m.right - m.left));
  const cur = document.getElementById('cursor');
  cur.style.left = `${x}px`;
  cur.style.top = `${m.top}px`;
  cur.style.height = `${(m.bottom - m.top)}px`;

  document.getElementById('hud').textContent = `page=${PAGE_IDX} meas=${i} x=${Math.round(x)} frac=${frac01.toFixed(3)}`;
}

function setPageAndSvg(pageIndex, svgPath) {
  PAGE_IDX = pageIndex;
  READY = false;
  MEASURE_BOXES = [];
  const obj = document.getElementById('page');
  obj.data = svgPath;
  document.getElementById('hud').textContent = `loading page=${pageIndex}…`;

  obj.addEventListener('load', () => {
    refreshBoxesAndHud();
  }, { once: true });
}

// Recompute on window resize (box sizes change)
window.addEventListener('resize', () => {
  if (svgEl()) refreshBoxesAndHud();
});
</script>
</body>
</html>
